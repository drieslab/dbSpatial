[{"path":"https://drieslab.github.io/dbSpatial/articles/class_structure.html","id":"class-structure","dir":"Articles","previous_headings":"","what":"Class Structure","title":"Class Structure","text":"dbSpatial package contains convenience functions working diverse spatial data sources file formats DuckDB spatial extension. information DuckDB spatial extension see DuckDB spatial extension. information loading multiple geospatial files DuckDB, see DuckDBfs package.","code":""},{"path":"https://drieslab.github.io/dbSpatial/articles/getting_started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started","text":"vignette demonstrates use dbSpatial package create DuckDB database spatial points polygons starting various data sources.","code":""},{"path":"https://drieslab.github.io/dbSpatial/articles/getting_started.html","id":"creating-a-duckdb-connection","dir":"Articles","previous_headings":"","what":"Creating a DuckDB connection","title":"Getting Started","text":"","code":"# create db connection in memory duckdb_conn = DBI::dbConnect(duckdb::duckdb(), \":memory:\")"},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/articles/getting_started.html","id":"from-data-frames","dir":"Articles","previous_headings":"Reading in spatial data from various sources","what":"From data.frames","title":"Getting Started","text":"","code":"# test data test_data = data.frame(x = 1:10, y = 1:10, id = 1:10)  # df, tbl # specify x and y column names to cast to a point geometry dbSpatial(conn = duckdb_conn,           name = \"test_points\",           value = test_data,           x_colName = \"x\",           y_colName = \"y\",           overwrite = TRUE) #> # Source:   table<test_points> [10 x 4] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>        x     y    id geom       #>    <int> <int> <int> <list>     #>  1     1     1     1 <raw [32]> #>  2     2     2     2 <raw [32]> #>  3     3     3     3 <raw [32]> #>  4     4     4     4 <raw [32]> #>  5     5     5     5 <raw [32]> #>  6     6     6     6 <raw [32]> #>  7     7     7     7 <raw [32]> #>  8     8     8     8 <raw [32]> #>  9     9     9     9 <raw [32]> #> 10    10    10    10 <raw [32]>"},{"path":"https://drieslab.github.io/dbSpatial/articles/getting_started.html","id":"from--csv-file","dir":"Articles","previous_headings":"Reading in spatial data from various sources","what":"From .csv file","title":"Getting Started","text":"","code":"# test data test_data = data.frame(x = 1:10, y = 1:10, id = 1:10)  # write to file write.csv(test_data, \"test_data.csv\", row.names = FALSE)  # load file in db dbSpatial(conn = duckdb_conn,           name = \"test_points\",           value = 'test_data.csv',           overwrite = TRUE) #> # Source:   table<test_points> [10 x 3] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>    x     y     id    #>    <chr> <chr> <chr> #>  1 1     1     1     #>  2 2     2     2     #>  3 3     3     3     #>  4 4     4     4     #>  5 5     5     5     #>  6 6     6     6     #>  7 7     7     7     #>  8 8     8     8     #>  9 9     9     9     #> 10 10    10    10"},{"path":"https://drieslab.github.io/dbSpatial/articles/getting_started.html","id":"from-terra-objects-spatvector","dir":"Articles","previous_headings":"Reading in spatial data from various sources","what":"From {terra} objects: SpatVector","title":"Getting Started","text":"","code":"# load terra package library(terra) #> terra 1.7.78  # Create a SpatVector from the data.frame dummy_spatvector <- terra::vect(test_data, geom = c(\"x\", \"y\"))  # Load SpatVector in db dbSpatial(conn = duckdb_conn,           name = \"spatVector_proxy\",           value = dummy_spatvector,           overwrite = TRUE) #> # Source:   table<spatVector_proxy> [10 x 2] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       id geom       #>    <dbl> <list>     #>  1     1 <raw [32]> #>  2     2 <raw [32]> #>  3     3 <raw [32]> #>  4     4 <raw [32]> #>  5     5 <raw [32]> #>  6     6 <raw [32]> #>  7     7 <raw [32]> #>  8     8 <raw [32]> #>  9     9 <raw [32]> #> 10    10 <raw [32]>"},{"path":"https://drieslab.github.io/dbSpatial/articles/spatial_operations.html","id":"spatial-operations-with-terra-comparisons","dir":"Articles","previous_headings":"","what":"Spatial Operations with {terra} Comparisons","title":"Spatial Operations","text":"","code":"# load libs library(dbSpatial) library(terra) #> terra 1.7.78 library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:terra': #>  #>     intersect, union #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union"},{"path":"https://drieslab.github.io/dbSpatial/articles/spatial_operations.html","id":"create-test-data","dir":"Articles","previous_headings":"Spatial Operations with {terra} Comparisons","what":"Create test data","title":"Spatial Operations","text":"","code":"# Create a data.frame with x and y coordinates and attributes coordinates <- data.frame(x = 1:1e3, y = 1:1e3) attributes <- data.frame(id = 1:1e3, name = paste(\"A\", 1:1e3, sep = \"_\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)  # Create a SpatVector from the data.frame dummy_spatvector <- terra::vect(dummy_data, geom = c(\"x\", \"y\"))  # DuckDB duckdb_conn = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  db_points = dbSpatial(conn = duckdb_conn,                       name = \"spatVector_proxy\",                       value = dummy_spatvector,                       overwrite = TRUE)  # Preview points table db_points |>   dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [?? x 4] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       id name  geom       geom_text     #>    <dbl> <chr> <list>     <chr>         #>  1     1 A_1   <raw [32]> POINT (1 1)   #>  2     2 A_2   <raw [32]> POINT (2 2)   #>  3     3 A_3   <raw [32]> POINT (3 3)   #>  4     4 A_4   <raw [32]> POINT (4 4)   #>  5     5 A_5   <raw [32]> POINT (5 5)   #>  6     6 A_6   <raw [32]> POINT (6 6)   #>  7     7 A_7   <raw [32]> POINT (7 7)   #>  8     8 A_8   <raw [32]> POINT (8 8)   #>  9     9 A_9   <raw [32]> POINT (9 9)   #> 10    10 A_10  <raw [32]> POINT (10 10) #> # ℹ more rows"},{"path":"https://drieslab.github.io/dbSpatial/articles/spatial_operations.html","id":"extent","dir":"Articles","previous_headings":"Spatial Operations with {terra} Comparisons > Create test data","what":"Extent","title":"Spatial Operations","text":"","code":"# terra terra::ext(dummy_spatvector) #> SpatExtent : 1, 1000, 1, 1000 (xmin, xmax, ymin, ymax)  # dbSpatial dbSpatial::st_extent(tbl = db_points) #> xmin xmax ymin ymax  #>    1 1000    1 1000"},{"path":"https://drieslab.github.io/dbSpatial/articles/spatial_operations.html","id":"is-valid","dir":"Articles","previous_headings":"Spatial Operations with {terra} Comparisons > Create test data","what":"Is.Valid","title":"Spatial Operations","text":"","code":"# terra head(terra::geom(dummy_spatvector)) #>      geom part x y hole #> [1,]    1    1 1 1    0 #> [2,]    2    1 2 2    0 #> [3,]    3    1 3 3    0 #> [4,]    4    1 4 4    0 #> [5,]    5    1 5 5    0 #> [6,]    6    1 6 6    0  head(terra::is.valid(dummy_spatvector)) #> [1] TRUE TRUE TRUE TRUE TRUE TRUE  dbSpatial::st_isvalid(tbl = db_points) #> # Source:   SQL [?? x 1] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>    geom  #>    <lgl> #>  1 TRUE  #>  2 TRUE  #>  3 TRUE  #>  4 TRUE  #>  5 TRUE  #>  6 TRUE  #>  7 TRUE  #>  8 TRUE  #>  9 TRUE  #> 10 TRUE  #> # ℹ more rows"},{"path":"https://drieslab.github.io/dbSpatial/articles/spatial_operations.html","id":"y-x-max","dir":"Articles","previous_headings":"Spatial Operations with {terra} Comparisons > Create test data","what":"Y, X Max","title":"Spatial Operations","text":"","code":"# terra head(terra::geom(dummy_spatvector)) #>      geom part x y hole #> [1,]    1    1 1 1    0 #> [2,]    2    1 2 2    0 #> [3,]    3    1 3 3    0 #> [4,]    4    1 4 4    0 #> [5,]    5    1 5 5    0 #> [6,]    6    1 6 6    0  terra::ymax(dummy_spatvector) #> [1] 1000  terra::xmax(dummy_spatvector) #> [1] 1000  # dbSpatial dbSpatial::st_ymax(db_points) #> # Source:   SQL [?? x 1] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>     geom #>    <dbl> #>  1     1 #>  2     2 #>  3     3 #>  4     4 #>  5     5 #>  6     6 #>  7     7 #>  8     8 #>  9     9 #> 10    10 #> # ℹ more rows  dbSpatial::st_xmax(db_points) #> # Source:   SQL [?? x 1] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>     geom #>    <dbl> #>  1     1 #>  2     2 #>  3     3 #>  4     4 #>  5     5 #>  6     6 #>  7     7 #>  8     8 #>  9     9 #> 10    10 #> # ℹ more rows"},{"path":"https://drieslab.github.io/dbSpatial/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Edward C. Ruiz. Author, maintainer. Jiaji George Chen. Author. Ruben Dries. Author, reviewer.","code":""},{"path":"https://drieslab.github.io/dbSpatial/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"C. Ruiz E, George Chen J, Dries R (2024). dbSpatial: dbSpatial. R package version 0.0.0.9008, https://drieslab.github.io/dbSpatial/.","code":"@Manual{,   title = {dbSpatial: dbSpatial},   author = {Edward {C. Ruiz} and Jiaji {George Chen} and Ruben Dries},   year = {2024},   note = {R package version 0.0.0.9008},   url = {https://drieslab.github.io/dbSpatial/}, }"},{"path":"https://drieslab.github.io/dbSpatial/index.html","id":"dbspatial","dir":"","previous_headings":"","what":"dbSpatial","title":"dbSpatial","text":"goal dbSpatial provide larger--memory spatial operations various spatial data sources. package largely relies DuckDB spatial extension.","code":""},{"path":"https://drieslab.github.io/dbSpatial/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"dbSpatial","text":"can install development version dbSpatial Github like :","code":"# install.packages(\"pak\", repos = sprintf(\"https://r-lib.github.io/p/pak/stable/%s/%s/%s\", .Platform$pkgType, R.Version()$os, R.Version()$arch)) pak::pak(\"drieslab/dbSpatial\")"},{"path":"https://drieslab.github.io/dbSpatial/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"dbSpatial","text":"DuckDB spatial extension can used wrapper functions package directly (ST_*()), dplyr verbs containing ST_*() functions, SQL queries DuckDB database connection containing ST_*() functions.","code":"library(dbSpatial)  # create duckdb db in memory duckdb_conn = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  # test data test_data = data.frame(x = 1:10, y = 1:10, id = 1:10)  points <- dbSpatial(conn = duckdb_conn,                     name = \"test_points\",                     value = test_data,                     x_colName = \"x\",                     y_colName = \"y\",                     overwrite = TRUE)  points #> # Source:   table<test_points> [10 x 4] #> # Database: DuckDB v0.10.0 [user@Linux 6.5.0-25-generic:R 4.1.2/:memory:] #>        x     y    id geom       #>    <int> <int> <int> <list>     #>  1     1     1     1 <raw [32]> #>  2     2     2     2 <raw [32]> #>  3     3     3     3 <raw [32]> #>  4     4     4     4 <raw [32]> #>  5     5     5     5 <raw [32]> #>  6     6     6     6 <raw [32]> #>  7     7     7     7 <raw [32]> #>  8     8     8     8 <raw [32]> #>  9     9     9     9 <raw [32]> #> 10    10    10    10 <raw [32]>"},{"path":"https://drieslab.github.io/dbSpatial/reference/dbSpatial.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a dbSpatial object with geometry — dbSpatial","title":"Create a dbSpatial object with geometry — dbSpatial","text":"Constructor function ingest variety spatial data inputs create dbSpatial object containing geometry data type based Simple Features standard. x_colName y_colName specified, point geometry constructed based columns.","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/dbSpatial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a dbSpatial object with geometry — dbSpatial","text":"","code":"dbSpatial(   value,   name,   conn,   x_colName = NULL,   y_colName = NULL,   geomName = \"geom\",   overwrite = FALSE,   ... )"},{"path":"https://drieslab.github.io/dbSpatial/reference/dbSpatial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a dbSpatial object with geometry — dbSpatial","text":"value value added database. Can data.frame, tbl_duckdb_connection, file path, sf object, terra object. See details information. name character. Name table add database. conn duckdb_connection. connection object DuckDB database. x_colName character. Name column containing numerical X coordinates. default = NULL. y_colName character. Name column containing numerical Y coordinates. default = NULL. geomName character. Name column containing geometry. Must start character. default = \"geom\". overwrite logical. Overwrite existing table. default = FALSE. ... Additional arguments passed","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/dbSpatial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a dbSpatial object with geometry — dbSpatial","text":"dbSpatial object.","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/dbSpatial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a dbSpatial object with geometry — dbSpatial","text":"list files supported see st_read. TODO: Support SDF, sf.","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/dbSpatial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a dbSpatial object with geometry — dbSpatial","text":"","code":"# create in-memory DuckDB db duckdb_conn = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  # test value test_data = data.frame(x = 1:10, y = 1:10, id = 1:10)  write.csv(test_data, \"test_data.csv\", row.names = FALSE)  # read data.frame and create point geometry dbSpatial(conn = duckdb_conn,           name = \"test_points\",           value = test_data,           x_colName = \"x\",           y_colName = \"y\",           overwrite = TRUE) #> # Source:   table<test_points> [10 x 4] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>        x     y    id geom       #>    <int> <int> <int> <list>     #>  1     1     1     1 <raw [32]> #>  2     2     2     2 <raw [32]> #>  3     3     3     3 <raw [32]> #>  4     4     4     4 <raw [32]> #>  5     5     5     5 <raw [32]> #>  6     6     6     6 <raw [32]> #>  7     7     7     7 <raw [32]> #>  8     8     8     8 <raw [32]> #>  9     9     9     9 <raw [32]> #> 10    10    10    10 <raw [32]>  # read csv dbSpatial(conn = duckdb_conn,           name = \"test_points\",           value = 'test_data.csv',           overwrite = TRUE) #> # Source:   table<test_points> [10 x 3] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>    x     y     id    #>    <chr> <chr> <chr> #>  1 1     1     1     #>  2 2     2     2     #>  3 3     3     3     #>  4 4     4     4     #>  5 5     5     5     #>  6 6     6     6     #>  7 7     7     7     #>  8 8     8     8     #>  9 9     9     9     #> 10 10    10    10"},{"path":"https://drieslab.github.io/dbSpatial/reference/dot-sim_dbSpatial.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate basic dbSpatial object — .sim_dbSpatial","title":"Simulate basic dbSpatial object — .sim_dbSpatial","text":"Simulate basic dbSpatial object","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/dot-sim_dbSpatial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate basic dbSpatial object — .sim_dbSpatial","text":"","code":".sim_dbSpatial()"},{"path":"https://drieslab.github.io/dbSpatial/reference/dot-sim_dbSpatial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate basic dbSpatial object — .sim_dbSpatial","text":"dbSpatial object","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/loadSpatial.html","id":null,"dir":"Reference","previous_headings":"","what":"Install and/or load DuckDB spatial extension — loadSpatial","title":"Install and/or load DuckDB spatial extension — loadSpatial","text":"Install /load DuckDB spatial extension","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/loadSpatial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Install and/or load DuckDB spatial extension — loadSpatial","text":"","code":"loadSpatial(conn)"},{"path":"https://drieslab.github.io/dbSpatial/reference/loadSpatial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Install and/or load DuckDB spatial extension — loadSpatial","text":"conn duckdb connection","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/loadSpatial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Install and/or load DuckDB spatial extension — loadSpatial","text":"","code":"duckdb_conn = DBI::dbConnect(duckdb::duckdb(), \":memory:\") loadSpatial(conn = duckdb_conn) #> DuckDB spatial extension installed and loaded"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_contains.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if geometries in two dbSpatial objects contain each other — st_contains","title":"Determine if geometries in two dbSpatial objects contain each other — st_contains","text":"https://postgis.net/docs/ST_Contains.html","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_contains.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if geometries in two dbSpatial objects contain each other — st_contains","text":"","code":"st_contains(   g1,   g1_geom_colName = \"geom\",   g1_cols_keep = \"all\",   g2,   g2_geom_colName = \"geom\",   g2_cols_keep = \"all\",   overwrite = FALSE,   output_tblName = \"contains_geom\" )"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_contains.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if geometries in two dbSpatial objects contain each other — st_contains","text":"g1 dbSpatial object. g1_geom_colName character. geometry column name g1. default: \"geom\" g1_cols_keep character vector. column names g1 keep operation. default: '' columns g2 dbSpatial object. g2_geom_colName character. geometry column name g2. default: \"geom\" g2_cols_keep character vector. column names g2 keep operation. default: '' columns overwrite logical. TRUE, overwrite existing table output_tblName. default: FALSE output_tblName character. name table store resulting data. default: \"contains_geom\"","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_contains.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if geometries in two dbSpatial objects contain each other — st_contains","text":"tbl_dbi","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_contains.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine if geometries in two dbSpatial objects contain each other — st_contains","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A1\", \"B1\", \"C1\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)   points <- dbSpatial(conn = con,                     name = \"points\",                      value = dummy_data,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\")  # preview                      points |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A1    <raw [32]> POINT (100 500) #> 2   200   600     2 B1    <raw [32]> POINT (200 600) #> 3   300   700     3 C1    <raw [32]> POINT (300 700)                      # Create a second set of points, with B1 and C1 translated by + 100 dummy_data2 <- dummy_data dummy_data2[c(2,3),c(1,2)] <- dummy_data2[c(2,3),c(1,2)] + 150 dummy_data2$name <- c('A2', 'B2', 'C2')  points2 <- dbSpatial(conn = con,                     name = \"points2\",                      value = dummy_data2,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\") # preview                      points2 |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A2    <raw [32]> POINT (100 500) #> 2   350   750     2 B2    <raw [32]> POINT (350 750) #> 3   450   850     3 C2    <raw [32]> POINT (450 850)  res <- st_contains(g1 = points,                     g1_cols_keep = c(\"name\"),                     g2 = points2,                    overwrite = TRUE)  res #> # Source:   table<contains_geom> [1 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>   name      x     y    id name_1 geom       #>   <chr> <dbl> <dbl> <int> <chr>  <list>     #> 1 A1      100   500     1 A2     <raw [32]>"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_coveredby.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if geometries in two dbSpatial objects are covered by each other — st_coveredby","title":"Determine if geometries in two dbSpatial objects are covered by each other — st_coveredby","text":"https://postgis.net/docs/ST_CoveredBy.html","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_coveredby.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if geometries in two dbSpatial objects are covered by each other — st_coveredby","text":"","code":"st_coveredby(   g1,   g1_geom_colName = \"geom\",   g1_cols_keep = \"all\",   g2,   g2_geom_colName = \"geom\",   g2_cols_keep = \"all\",   overwrite = FALSE,   output_tblName = \"coveredby_geom\" )"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_coveredby.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if geometries in two dbSpatial objects are covered by each other — st_coveredby","text":"g1 dbSpatial object. g1_geom_colName character. geometry column name g1. default: \"geom\" g1_cols_keep character vector. column names g1 keep operation. default: '' columns g2 dbSpatial object. g2_geom_colName character. geometry column name g2. default: \"geom\" g2_cols_keep character vector. column names g2 keep operation. default: '' columns overwrite logical. TRUE, overwrite existing table output_tblName. default: FALSE output_tblName character. name table store resulting data. default: \"coveredby_geom\"","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_coveredby.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if geometries in two dbSpatial objects are covered by each other — st_coveredby","text":"tbl_dbi","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_coveredby.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine if geometries in two dbSpatial objects are covered by each other — st_coveredby","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A1\", \"B1\", \"C1\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)   points <- dbSpatial(conn = con,                     name = \"points\",                      value = dummy_data,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\")  # preview                      points |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A1    <raw [32]> POINT (100 500) #> 2   200   600     2 B1    <raw [32]> POINT (200 600) #> 3   300   700     3 C1    <raw [32]> POINT (300 700)                      # Create a second set of points, with B1 and C1 translated by + 100 dummy_data2 <- dummy_data dummy_data2[c(2,3),c(1,2)] <- dummy_data2[c(2,3),c(1,2)] + 150 dummy_data2$name <- c('A2', 'B2', 'C2')  points2 <- dbSpatial(conn = con,                     name = \"points2\",                      value = dummy_data2,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\") # preview                      points2 |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A2    <raw [32]> POINT (100 500) #> 2   350   750     2 B2    <raw [32]> POINT (350 750) #> 3   450   850     3 C2    <raw [32]> POINT (450 850)  res <- st_coveredby(g1 = points,                       g1_cols_keep = c(\"name\"),                       g2 = points2,                      overwrite = TRUE)  res #> # Source:   table<coveredby_geom> [1 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>   name      x     y    id name_1 geom       #>   <chr> <dbl> <dbl> <int> <chr>  <list>     #> 1 A1      100   500     1 A2     <raw [32]>"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_covers.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if geometries in two dbSpatial objects are covering each other — st_covers","title":"Determine if geometries in two dbSpatial objects are covering each other — st_covers","text":"https://postgis.net/docs/ST_Covers.html","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_covers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if geometries in two dbSpatial objects are covering each other — st_covers","text":"","code":"st_covers(   g1,   g1_geom_colName = \"geom\",   g1_cols_keep = \"all\",   g2,   g2_geom_colName = \"geom\",   g2_cols_keep = \"all\",   overwrite = FALSE,   output_tblName = \"covers_geom\" )"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_covers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if geometries in two dbSpatial objects are covering each other — st_covers","text":"g1 dbSpatial object. g1_geom_colName character. geometry column name g1. default: \"geom\" g1_cols_keep character vector. column names g1 keep operation. default: '' columns g2 dbSpatial object. g2_geom_colName character. geometry column name g2. default: \"geom\" g2_cols_keep character vector. column names g2 keep operation. default: '' columns overwrite logical. TRUE, overwrite existing table output_tblName. default: FALSE output_tblName character. name table store resulting data. default: \"covers_geom\"","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_covers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if geometries in two dbSpatial objects are covering each other — st_covers","text":"tbl_dbi","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_covers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine if geometries in two dbSpatial objects are covering each other — st_covers","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A1\", \"B1\", \"C1\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)   points <- dbSpatial(conn = con,                     name = \"points\",                      value = dummy_data,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\")  # preview                      points |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A1    <raw [32]> POINT (100 500) #> 2   200   600     2 B1    <raw [32]> POINT (200 600) #> 3   300   700     3 C1    <raw [32]> POINT (300 700)                      # Create a second set of points, with B1 and C1 translated by + 100 dummy_data2 <- dummy_data dummy_data2[c(2,3),c(1,2)] <- dummy_data2[c(2,3),c(1,2)] + 150 dummy_data2$name <- c('A2', 'B2', 'C2')  points2 <- dbSpatial(conn = con,                     name = \"points2\",                      value = dummy_data2,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\") # preview                      points2 |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A2    <raw [32]> POINT (100 500) #> 2   350   750     2 B2    <raw [32]> POINT (350 750) #> 3   450   850     3 C2    <raw [32]> POINT (450 850)  res <- st_covers(g1 = points,                   g1_cols_keep = c(\"name\"),                   g2 = points2,                  overwrite = TRUE)  res #> # Source:   table<covers_geom> [1 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>   name      x     y    id name_1 geom       #>   <chr> <dbl> <dbl> <int> <chr>  <list>     #> 1 A1      100   500     1 A2     <raw [32]>"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_crosses.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if geometries in two dbSpatial objects are crossing — st_crosses","title":"Determine if geometries in two dbSpatial objects are crossing — st_crosses","text":"https://postgis.net/docs/ST_Crosses.html","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_crosses.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if geometries in two dbSpatial objects are crossing — st_crosses","text":"","code":"st_crosses(   g1,   g1_geom_colName = \"geom\",   g1_cols_keep = \"all\",   g2,   g2_geom_colName = \"geom\",   g2_cols_keep = \"all\",   overwrite = FALSE,   output_tblName = \"crosses_geom\" )"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_crosses.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if geometries in two dbSpatial objects are crossing — st_crosses","text":"g1 dbSpatial object. g1_geom_colName character. geometry column name g1. default: \"geom\" g1_cols_keep character vector. column names g1 keep operation. default: '' columns g2 dbSpatial object. g2_geom_colName character. geometry column name g2. default: \"geom\" g2_cols_keep character vector. column names g2 keep operation. default: '' columns overwrite logical. TRUE, overwrite existing table output_tblName. default: FALSE output_tblName character. name table store resulting data. default: \"crosses_geom\"","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_crosses.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if geometries in two dbSpatial objects are crossing — st_crosses","text":"tbl_dbi","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_crosses.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine if geometries in two dbSpatial objects are crossing — st_crosses","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A1\", \"B1\", \"C1\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)   points <- dbSpatial(conn = con,                     name = \"points\",                      value = dummy_data,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\")  # preview                      points |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A1    <raw [32]> POINT (100 500) #> 2   200   600     2 B1    <raw [32]> POINT (200 600) #> 3   300   700     3 C1    <raw [32]> POINT (300 700)                      # Create a second set of points, with B1 and C1 translated by + 100 dummy_data2 <- dummy_data dummy_data2[c(2,3),c(1,2)] <- dummy_data2[c(2,3),c(1,2)] + 150 dummy_data2$name <- c('A2', 'B2', 'C2')  points2 <- dbSpatial(conn = con,                     name = \"points2\",                      value = dummy_data2,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\") # preview                      points2 |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A2    <raw [32]> POINT (100 500) #> 2   350   750     2 B2    <raw [32]> POINT (350 750) #> 3   450   850     3 C2    <raw [32]> POINT (450 850)  res <- st_crosses(g1 = points,                    g1_cols_keep = c(\"name\"),                    g2 = points2,                   overwrite = TRUE)  res #> # Source:   table<crosses_geom> [0 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #> # ℹ 6 variables: name <chr>, x <dbl>, y <dbl>, id <int>, name_1 <chr>, #> #   geom <list>"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_difference.html","id":null,"dir":"Reference","previous_headings":"","what":"Find difference in geometries between two dbSpatial objects — st_difference","title":"Find difference in geometries between two dbSpatial objects — st_difference","text":"Adds column 'st_difference' resulting table containing difference geometries g1 g2.","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_difference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find difference in geometries between two dbSpatial objects — st_difference","text":"","code":"st_difference(   g1,   g1_geom_colName = \"geom\",   g1_cols_keep = \"all\",   g2,   g2_geom_colName = \"geom\",   g2_cols_keep = \"all\",   overwrite = FALSE,   output_tblName = \"difference_geom\" )"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_difference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find difference in geometries between two dbSpatial objects — st_difference","text":"g1 dbSpatial object. g1_geom_colName character. geometry column name g1. default: \"geom\" g1_cols_keep character vector. column names g1 keep operation. default: '' columns g2 dbSpatial object. g2_geom_colName character. geometry column name g2. default: \"geom\" g2_cols_keep character vector. column names g2 keep operation. default: '' columns overwrite logical. TRUE, overwrite existing table output_tblName. default: FALSE output_tblName character. name table store resulting data. default: \"difference_geom\"","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_difference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find difference in geometries between two dbSpatial objects — st_difference","text":"tbl_dbi","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_difference.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find difference in geometries between two dbSpatial objects — st_difference","text":"https://postgis.net/docs/ST_Difference.html","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_difference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find difference in geometries between two dbSpatial objects — st_difference","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  polys <- dbSpatial(conn = con,                    name = \"polys\",                    value = system.file(\"data\", \"dummy_polygons.geojson\", package = \"dbSpatial\"),                    overwrite = TRUE,                    x_colName = \"x\",                    y_colName = \"y\") #> Error in .check_value(value): Invalid \"value\" input passed.  polys2 <- dbSpatial(conn = con,                    name = \"polys2\",                    value = system.file(\"data\", \"dummy_polygons.geojson\", package = \"dbSpatial\"),                    overwrite = TRUE,                    x_colName = \"x\",                    y_colName = \"y\") #> Error in .check_value(value): Invalid \"value\" input passed.  res <- st_difference(g1 = polys,                       g2 = polys2,                      overwrite = TRUE) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'dbObj' in selecting a method for function 'dbIsValid': object 'polys' not found  res #> Error in eval(expr, envir, enclos): object 'res' not found"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_disjoint.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if geometries between two dbSpatial objects are disjoint — st_disjoint","title":"Determine if geometries between two dbSpatial objects are disjoint — st_disjoint","text":"https://postgis.net/docs/ST_Disjoint.html","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_disjoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if geometries between two dbSpatial objects are disjoint — st_disjoint","text":"","code":"st_disjoint(   g1,   g1_geom_colName = \"geom\",   g1_cols_keep = \"all\",   g2,   g2_geom_colName = \"geom\",   g2_cols_keep = \"all\",   overwrite = FALSE,   output_tblName = \"disjoint_geom\" )"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_disjoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if geometries between two dbSpatial objects are disjoint — st_disjoint","text":"g1 dbSpatial object. g1_geom_colName character. geometry column name g1. default: \"geom\" g1_cols_keep character vector. column names g1 keep operation. default: '' columns g2 dbSpatial object. g2_geom_colName character. geometry column name g2. default: \"geom\" g2_cols_keep character vector. column names g2 keep operation. default: '' columns overwrite logical. TRUE, overwrite existing table output_tblName. default: FALSE output_tblName character. name table store resulting data. default: \"disjoint_geom\"","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_disjoint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if geometries between two dbSpatial objects are disjoint — st_disjoint","text":"tbl_dbi","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_disjoint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine if geometries between two dbSpatial objects are disjoint — st_disjoint","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A1\", \"B1\", \"C1\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)   points <- dbSpatial(conn = con,                     name = \"points\",                      value = dummy_data,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\")  # preview                      points |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A1    <raw [32]> POINT (100 500) #> 2   200   600     2 B1    <raw [32]> POINT (200 600) #> 3   300   700     3 C1    <raw [32]> POINT (300 700)                      # Create a second set of points, with B1 and C1 translated by + 100 dummy_data2 <- dummy_data dummy_data2[c(2,3),c(1,2)] <- dummy_data2[c(2,3),c(1,2)] + 150 dummy_data2$name <- c('A2', 'B2', 'C2')  points2 <- dbSpatial(conn = con,                     name = \"points2\",                      value = dummy_data2,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\") # preview                      points2 |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A2    <raw [32]> POINT (100 500) #> 2   350   750     2 B2    <raw [32]> POINT (350 750) #> 3   450   850     3 C2    <raw [32]> POINT (450 850)  res <- st_disjoint(g1 = points,                     g1_cols_keep = c(\"name\"),                     g2 = points2,                    overwrite = TRUE)  res #> # Source:   table<disjoint_geom> [8 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>   name      x     y    id name_1 geom       #>   <chr> <dbl> <dbl> <int> <chr>  <list>     #> 1 A1      350   750     2 B2     <raw [32]> #> 2 A1      450   850     3 C2     <raw [32]> #> 3 B1      100   500     1 A2     <raw [32]> #> 4 B1      350   750     2 B2     <raw [32]> #> 5 B1      450   850     3 C2     <raw [32]> #> 6 C1      100   500     1 A2     <raw [32]> #> 7 C1      350   750     2 B2     <raw [32]> #> 8 C1      450   850     3 C2     <raw [32]>"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Find distance between geometries in two dbSpatial objects — st_distance","title":"Find distance between geometries in two dbSpatial objects — st_distance","text":"https://postgis.net/docs/ST_Distance.html Adds column 'st_distance' resulting table containing distance geometries g1 g2.","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find distance between geometries in two dbSpatial objects — st_distance","text":"","code":"st_distance(   g1,   g1_geom_colName = \"geom\",   g1_cols_keep = \"all\",   g2,   g2_geom_colName = \"geom\",   g2_cols_keep = \"all\",   overwrite = FALSE,   output_tblName = \"distance_geom\" )"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find distance between geometries in two dbSpatial objects — st_distance","text":"g1 dbSpatial object. g1_geom_colName character. geometry column name g1. default: \"geom\" g1_cols_keep character vector. column names g1 keep operation. default: '' columns g2 dbSpatial object. g2_geom_colName character. geometry column name g2. default: \"geom\" g2_cols_keep character vector. column names g2 keep operation. default: '' columns overwrite logical. TRUE, overwrite existing table output_tblName. default: FALSE output_tblName character. name table store resulting data. default: \"distance_geom\"","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find distance between geometries in two dbSpatial objects — st_distance","text":"tbl_dbi","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find distance between geometries in two dbSpatial objects — st_distance","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A1\", \"B1\", \"C1\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)   points <- dbSpatial(conn = con,                     name = \"points\",                      value = dummy_data,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\")  # preview                      points |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A1    <raw [32]> POINT (100 500) #> 2   200   600     2 B1    <raw [32]> POINT (200 600) #> 3   300   700     3 C1    <raw [32]> POINT (300 700)                      # Create a second set of points, with B1 and C1 translated by + 100 dummy_data2 <- dummy_data dummy_data2[c(2,3),c(1,2)] <- dummy_data2[c(2,3),c(1,2)] + 150 dummy_data2$name <- c('A2', 'B2', 'C2')  points2 <- dbSpatial(conn = con,                     name = \"points2\",                      value = dummy_data2,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\") # preview                      points2 |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A2    <raw [32]> POINT (100 500) #> 2   350   750     2 B2    <raw [32]> POINT (350 750) #> 3   450   850     3 C2    <raw [32]> POINT (450 850)  res <- st_distance(g1 = points,                     g1_cols_keep = c(\"name\"),                     g2 = points2,                    overwrite = TRUE)  res #> # Source:   table<distance_geom> [9 x 7] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>   name      x     y    id name_1 geom       st_distance #>   <chr> <dbl> <dbl> <int> <chr>  <list>           <dbl> #> 1 A1      100   500     1 A2     <raw [32]>         0   #> 2 A1      350   750     2 B2     <raw [32]>       354.  #> 3 A1      450   850     3 C2     <raw [32]>       495.  #> 4 B1      100   500     1 A2     <raw [32]>       141.  #> 5 B1      350   750     2 B2     <raw [32]>       212.  #> 6 B1      450   850     3 C2     <raw [32]>       354.  #> 7 C1      100   500     1 A2     <raw [32]>       283.  #> 8 C1      350   750     2 B2     <raw [32]>        70.7 #> 9 C1      450   850     3 C2     <raw [32]>       212."},{"path":"https://drieslab.github.io/dbSpatial/reference/st_equals.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if geometries between two dbSpatial objects are equal — st_equals","title":"Determine if geometries between two dbSpatial objects are equal — st_equals","text":"https://postgis.net/docs/ST_Equals.html","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_equals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if geometries between two dbSpatial objects are equal — st_equals","text":"","code":"st_equals(   g1,   g1_geom_colName = \"geom\",   g1_cols_keep = \"all\",   g2,   g2_geom_colName = \"geom\",   g2_cols_keep = \"all\",   overwrite = FALSE,   output_tblName = \"equals_geom\" )"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_equals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if geometries between two dbSpatial objects are equal — st_equals","text":"g1 dbSpatial object. g1_geom_colName character. geometry column name g1. default: \"geom\" g1_cols_keep character vector. column names g1 keep operation. default: '' columns g2 dbSpatial object. g2_geom_colName character. geometry column name g2. default: \"geom\" g2_cols_keep character vector. column names g2 keep operation. default: '' columns overwrite logical. TRUE, overwrite existing table output_tblName. default: FALSE output_tblName character. name table store resulting data. default: \"equals_geom\"","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_equals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if geometries between two dbSpatial objects are equal — st_equals","text":"tbl_dbi","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_equals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine if geometries between two dbSpatial objects are equal — st_equals","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A1\", \"B1\", \"C1\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)   points <- dbSpatial(conn = con,                     name = \"points\",                      value = dummy_data,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\")  # preview                      points |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A1    <raw [32]> POINT (100 500) #> 2   200   600     2 B1    <raw [32]> POINT (200 600) #> 3   300   700     3 C1    <raw [32]> POINT (300 700)                      # Create a second set of points, with B1 and C1 translated by + 100 dummy_data2 <- dummy_data dummy_data2[c(2,3),c(1,2)] <- dummy_data2[c(2,3),c(1,2)] + 150 dummy_data2$name <- c('A2', 'B2', 'C2')  points2 <- dbSpatial(conn = con,                     name = \"points2\",                      value = dummy_data2,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\") # preview                      points2 |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A2    <raw [32]> POINT (100 500) #> 2   350   750     2 B2    <raw [32]> POINT (350 750) #> 3   450   850     3 C2    <raw [32]> POINT (450 850)  res <- st_equals(g1 = points,                   g1_cols_keep = c(\"name\"),                   g2 = points2,                  overwrite = TRUE)  res #> # Source:   table<equals_geom> [1 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>   name      x     y    id name_1 geom       #>   <chr> <dbl> <dbl> <int> <chr>  <list>     #> 1 A1      100   500     1 A2     <raw [32]>"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_extent.html","id":null,"dir":"Reference","previous_headings":"","what":"Get extent of a geometry — st_extent","title":"Get extent of a geometry — st_extent","text":"Get extent geometry","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_extent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get extent of a geometry — st_extent","text":"","code":"st_extent(tbl, geomName = \"geom\")"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_extent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get extent of a geometry — st_extent","text":"tbl name table duckdb database containing geometry column geomName name column containing geometry value tbl","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_extent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get extent of a geometry — st_extent","text":"numeric vector extent geom column tbl","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_extent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get extent of a geometry — st_extent","text":"","code":"# Create a data.frame with x and y coordinates and attributes coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A\", \"B\", \"C\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)  # Create a duckdb connection con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  # Create a duckdb table with spatial points db_points = dbSpatial(conn = con,                       value = dummy_data,                       x_colName = \"x\",                       y_colName = \"y\",                       name = \"foo\",                       overwrite = TRUE)                        # Get extent of the table st_extent(db_points) #> xmin xmax ymin ymax  #>  100  300  500  700"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_geometrytype.html","id":null,"dir":"Reference","previous_headings":"","what":"Return geometry type — st_geometrytype","title":"Return geometry type — st_geometrytype","text":"function returns geometry type specified geometry column specified table.","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_geometrytype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return geometry type — st_geometrytype","text":"","code":"st_geometrytype(tbl, geomName = \"geom\")"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_geometrytype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return geometry type — st_geometrytype","text":"tbl name table duckdb database geomName name column containing geometry value tbl. default = \"geom\".","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_geometrytype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return geometry type — st_geometrytype","text":"character vector database","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_geometrytype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return geometry type — st_geometrytype","text":"","code":"# Create a data.frame with x and y coordinates and attributes coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A\", \"B\", \"C\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)  # Create a duckdb connection con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  # Create a duckdb table with spatial points db_points = dbSpatial(conn = con,                       value = dummy_data,                       x_colName = \"x\",                       y_colName = \"y\",                       name = \"foo\",                       overwrite = TRUE)                        st_geometrytype(tbl = db_points) #> # Source:   SQL [3 x 1] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>   geom  #>   <fct> #> 1 POINT #> 2 POINT #> 3 POINT"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_intersects.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if geometries between two dbSpatial objects are intersecting — st_intersects","title":"Determine if geometries between two dbSpatial objects are intersecting — st_intersects","text":"https://postgis.net/docs/ST_Intersects.html","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_intersects.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if geometries between two dbSpatial objects are intersecting — st_intersects","text":"","code":"st_intersects(   g1,   g1_geom_colName = \"geom\",   g1_cols_keep = \"all\",   g2,   g2_geom_colName = \"geom\",   g2_cols_keep = \"all\",   overwrite = FALSE,   output_tblName = \"intersect_geom\" )"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_intersects.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if geometries between two dbSpatial objects are intersecting — st_intersects","text":"g1 dbSpatial object. g1_geom_colName character. geometry column name g1. default: \"geom\" g1_cols_keep character vector. column names g1 keep operation. default: '' columns g2 dbSpatial object. g2_geom_colName character. geometry column name g2. default: \"geom\" g2_cols_keep character vector. column names g2 keep operation. default: '' columns overwrite logical. TRUE, overwrite existing table output_tblName. default: FALSE output_tblName character. name table store resulting data. default: \"intersect_geom\"","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_intersects.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if geometries between two dbSpatial objects are intersecting — st_intersects","text":"tbl_dbi","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_intersects.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine if geometries between two dbSpatial objects are intersecting — st_intersects","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A1\", \"B1\", \"C1\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)   points <- dbSpatial(conn = con,                     name = \"points\",                      value = dummy_data,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\")  # preview                      points |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A1    <raw [32]> POINT (100 500) #> 2   200   600     2 B1    <raw [32]> POINT (200 600) #> 3   300   700     3 C1    <raw [32]> POINT (300 700)                      # Create a second set of points, with B1 and C1 translated by + 100 dummy_data2 <- dummy_data dummy_data2[c(2,3),c(1,2)] <- dummy_data2[c(2,3),c(1,2)] + 150 dummy_data2$name <- c('A2', 'B2', 'C2')  points2 <- dbSpatial(conn = con,                     name = \"points2\",                      value = dummy_data2,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\") # preview                      points2 |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A2    <raw [32]> POINT (100 500) #> 2   350   750     2 B2    <raw [32]> POINT (350 750) #> 3   450   850     3 C2    <raw [32]> POINT (450 850)  res <- st_intersects(g1 = points,                       g1_cols_keep = c(\"name\"),                       g2 = points2,                      overwrite = TRUE)  res #> # Source:   table<intersect_geom> [1 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>   name      x     y    id name_1 geom       #>   <chr> <dbl> <dbl> <int> <chr>  <list>     #> 1 A1      100   500     1 A2     <raw [32]>"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_isvalid.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if geometry is valid — st_isvalid","title":"Determine if geometry is valid — st_isvalid","text":"function returns whether specified geometry column specified table valid .","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_isvalid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if geometry is valid — st_isvalid","text":"","code":"st_isvalid(tbl, geomName = \"geom\")"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_isvalid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if geometry is valid — st_isvalid","text":"tbl name table duckdb database geomName name column containing geometry value tbl. default = \"geom\".","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_isvalid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if geometry is valid — st_isvalid","text":"boolean vector database","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_isvalid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine if geometry is valid — st_isvalid","text":"","code":"# Create a data.frame with x and y coordinates and attributes coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A\", \"B\", \"C\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)  # Create a SpatVector from the data.frame dummy_spatvector <- terra::vect(dummy_data, geom = c(\"x\", \"y\"))  # Create a duckdb connection duckdb_conn = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  # Create a duckdb table with spatial points db_points = dbSpatial(conn = duckdb_conn,                       name = \"spatVector_proxy\",                       value = dummy_spatvector,                       overwrite = TRUE)  # Get extent of the table st_isvalid(db_points) #> # Source:   SQL [3 x 1] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>   geom  #>   <lgl> #> 1 TRUE  #> 2 TRUE  #> 3 TRUE"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_read.html","id":null,"dir":"Reference","previous_headings":"","what":"Read spatial data from a file and create a table in a duckdb database — st_read","title":"Read spatial data from a file and create a table in a duckdb database — st_read","text":"Read spatial data file create table duckdb database","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_read.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read spatial data from a file and create a table in a duckdb database — st_read","text":"","code":"st_read(conn, name, value, overwrite = FALSE, ...)"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_read.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read spatial data from a file and create a table in a duckdb database — st_read","text":"conn duckdb connection name name table created value data.frame file path overwrite logical; TRUE, overwrite table already exists ... additional arguments pass st_read","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_read.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read spatial data from a file and create a table in a duckdb database — st_read","text":"tbl_dbi","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_read.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read spatial data from a file and create a table in a duckdb database — st_read","text":"list files supported see documentation . https://DuckDB.org/docs/extensions/spatial.html#st_read---read-spatial-value--files","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_read.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read spatial data from a file and create a table in a duckdb database — st_read","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A\", \"B\", \"C\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)  write.csv(dummy_data, \"dummy_data.csv\", row.names = FALSE)   data <- st_read(conn = con,                  name = \"points\",                  value = \"dummy_data.csv\",                  overwrite = TRUE)  data #> # Source:   table<points> [3 x 4] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>   x     y     id    name  #>   <chr> <chr> <chr> <chr> #> 1 100   500   1     A     #> 2 200   600   2     B     #> 3 300   700   3     C"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_touches.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine if geometries between two dbSpatial objects are touching — st_touches","title":"Determine if geometries between two dbSpatial objects are touching — st_touches","text":"https://postgis.net/docs/ST_Touches.html","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_touches.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine if geometries between two dbSpatial objects are touching — st_touches","text":"","code":"st_touches(   g1,   g1_geom_colName = \"geom\",   g1_cols_keep = \"all\",   g2,   g2_geom_colName = \"geom\",   g2_cols_keep = \"all\",   overwrite = FALSE,   output_tblName = \"touches_geom\" )"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_touches.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine if geometries between two dbSpatial objects are touching — st_touches","text":"g1 dbSpatial object. g1_geom_colName character. geometry column name g1. default: \"geom\" g1_cols_keep character vector. column names g1 keep operation. default: '' columns g2 dbSpatial object. g2_geom_colName character. geometry column name g2. default: \"geom\" g2_cols_keep character vector. column names g2 keep operation. default: '' columns overwrite logical. TRUE, overwrite existing table output_tblName. default: FALSE output_tblName character. name table store resulting data. default: \"touches_geom\"","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_touches.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine if geometries between two dbSpatial objects are touching — st_touches","text":"tbl_dbi","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_touches.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine if geometries between two dbSpatial objects are touching — st_touches","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A1\", \"B1\", \"C1\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)   points <- dbSpatial(conn = con,                     name = \"points\",                      value = dummy_data,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\")  # preview                      points |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A1    <raw [32]> POINT (100 500) #> 2   200   600     2 B1    <raw [32]> POINT (200 600) #> 3   300   700     3 C1    <raw [32]> POINT (300 700)                      # Create a second set of points, with B1 and C1 translated by + 100 dummy_data2 <- dummy_data dummy_data2[c(2,3),c(1,2)] <- dummy_data2[c(2,3),c(1,2)] + 150 dummy_data2$name <- c('A2', 'B2', 'C2')  points2 <- dbSpatial(conn = con,                     name = \"points2\",                      value = dummy_data2,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\") # preview                      points2 |>    dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A2    <raw [32]> POINT (100 500) #> 2   350   750     2 B2    <raw [32]> POINT (350 750) #> 3   450   850     3 C2    <raw [32]> POINT (450 850)  res <- st_touches(g1 = points,                    g1_cols_keep = c(\"name\"),                    g2 = points2,                   overwrite = TRUE)  res #> # Source:   table<touches_geom> [0 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #> # ℹ 6 variables: name <chr>, x <dbl>, y <dbl>, id <int>, name_1 <chr>, #> #   geom <list>"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_translate.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate x, y coordinates by delta x, delta y for point geometries — st_translate","title":"Translate x, y coordinates by delta x, delta y for point geometries — st_translate","text":"Translate x, y coordinates delta x, delta y point geometries","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_translate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate x, y coordinates by delta x, delta y for point geometries — st_translate","text":"","code":"st_translate(tbl, geomName = \"geom\", dx, dy)"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_translate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate x, y coordinates by delta x, delta y for point geometries — st_translate","text":"tbl name table duckdb database geomName name column containing geometry value tbl. default = \"geom\". dx delta x dy delta y","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_translate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Translate x, y coordinates by delta x, delta y for point geometries — st_translate","text":"duckdb table translated geometries","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_translate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translate x, y coordinates by delta x, delta y for point geometries — st_translate","text":"","code":"con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A\", \"B\", \"C\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)   points <- dbSpatial(conn = con,                     name = \"points\",                      value = dummy_data,                      overwrite = TRUE,                      x_colName = \"x\",                      y_colName = \"y\")  points |>  dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A     <raw [32]> POINT (100 500) #> 2   200   600     2 B     <raw [32]> POINT (200 600) #> 3   300   700     3 C     <raw [32]> POINT (300 700)  points_translated <- st_translate(tbl = points, dx = 100, dy = -20)  points_translated |>   dplyr::mutate(geom_text = ST_AsText(geom)) #> # Source:   SQL [3 x 6] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>       x     y    id name  geom       geom_text       #>   <dbl> <dbl> <int> <chr> <list>     <chr>           #> 1   100   500     1 A     <raw [32]> POINT (200 480) #> 2   200   600     2 B     <raw [32]> POINT (300 580) #> 3   300   700     3 C     <raw [32]> POINT (400 680)"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_xmax.html","id":null,"dir":"Reference","previous_headings":"","what":"Get maximum x coordinate — st_xmax","title":"Get maximum x coordinate — st_xmax","text":"function returns maximum x coordinate geometry specified dbSpatial object.","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_xmax.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get maximum x coordinate — st_xmax","text":"","code":"st_xmax(tbl, geomName = \"geom\")"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_xmax.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get maximum x coordinate — st_xmax","text":"tbl name table duckdb database geomName name column containing geometry value tbl default = \"geom\".","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_xmax.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get maximum x coordinate — st_xmax","text":"numerical vector database","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_xmax.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get maximum x coordinate — st_xmax","text":"","code":"# Create a data.frame with x and y coordinates and attributes coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A\", \"B\", \"C\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)  # Create a duckdb connection con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  # Create a duckdb table with spatial points db_points = dbSpatial(conn = con,                       value = dummy_data,                       x_colName = \"x\",                       y_colName = \"y\",                       name = \"foo\",                       overwrite = TRUE)                        st_xmax(tbl = db_points) #> # Source:   SQL [3 x 1] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>    geom #>   <dbl> #> 1   100 #> 2   200 #> 3   300"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_ymax.html","id":null,"dir":"Reference","previous_headings":"","what":"Get maximum y coordinate — st_ymax","title":"Get maximum y coordinate — st_ymax","text":"Get maximum y coordinate","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_ymax.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get maximum y coordinate — st_ymax","text":"","code":"st_ymax(tbl, geomName = \"geom\")"},{"path":"https://drieslab.github.io/dbSpatial/reference/st_ymax.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get maximum y coordinate — st_ymax","text":"tbl name table duckdb database geomName name column containing geometry value tbl default = \"geom\".","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/st_ymax.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get maximum y coordinate — st_ymax","text":"numerical vector database","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/st_ymax.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get maximum y coordinate — st_ymax","text":"","code":"# Create a data.frame with x and y coordinates and attributes coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A\", \"B\", \"C\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)  # Create a duckdb connection con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  # Create a duckdb table with spatial points db_points = dbSpatial(conn = con,                       value = dummy_data,                       x_colName = \"x\",                       y_colName = \"y\",                       name = \"foo\",                       overwrite = TRUE)                        st_ymax(tbl = db_points) #> # Source:   SQL [3 x 1] #> # Database: DuckDB v1.0.0 [unknown@Linux 6.5.0-1023-azure:R 4.4.1/:memory:] #>    geom #>   <dbl> #> 1   500 #> 2   600 #> 3   700"},{"path":"https://drieslab.github.io/dbSpatial/reference/tessellate.html","id":null,"dir":"Reference","previous_headings":"","what":"Tessellate a dbSpatial object — tessellate","title":"Tessellate a dbSpatial object — tessellate","text":"Creates tessellation extent dbSpatial specified parameters. tessellation can composed hexagons squares.","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/tessellate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tessellate a dbSpatial object — tessellate","text":"","code":"tessellate(   dbSpatial,   geomName = \"geom\",   name = \"tessellation\",   shape = c(\"hexagon\", \"square\"),   shape_size = NULL,   gap = 0,   radius = NULL,   overwrite = FALSE,   ... )"},{"path":"https://drieslab.github.io/dbSpatial/reference/tessellate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tessellate a dbSpatial object — tessellate","text":"dbSpatial dbSpatial object representing spatial table. geomName character string specifying name geometry column database. name character string specifying name tessellation. shape character string indicating shape tessellation. Options \"hexagon\" \"square\". shape_size numeric value specifying size shapes tessellation. NULL, default size calculated. See GiottoClass::tessellate details. gap numeric value indicating gap tessellation shapes. Defaults 0. radius numeric value specifying radius hexagonal tessellation. parameter ignored square tessellations. overwrite logical value indicating whether overwrite existing tessellation name. Default: FALSE. ... Additional arguments passed underlying tessellation functions.","code":""},{"path":"https://drieslab.github.io/dbSpatial/reference/tessellate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tessellate a dbSpatial object — tessellate","text":"function writes tessellation database connected dbSpatial returns invisibly.","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/reference/tessellate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tessellate a dbSpatial object — tessellate","text":"","code":"coordinates <- data.frame(x = c(100, 200, 300), y = c(500, 600, 700)) attributes <- data.frame(id = 1:3, name = c(\"A\", \"B\", \"C\"))  # Combine the coordinates and attributes dummy_data <- cbind(coordinates, attributes)  # Create a duckdb connection con = DBI::dbConnect(duckdb::duckdb(), \":memory:\")  # Create a duckdb table with spatial points db_points = dbSpatial(conn = con,                       value = dummy_data,                       x_colName = \"x\",                       y_colName = \"y\",                       name = \"foo\",                       overwrite = TRUE)                        tessellate(db_points, name = \"my_tessellation\", shape = \"hexagon\", shape_size = 60) #> Error in loadNamespace(x): there is no package called ‘GiottoClass’"},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"docs-0-0-0-9008","dir":"Changelog","previous_headings":"","what":"Docs","title":"dbSpatial 0.0.0.9008 (2024-07-03)","text":"Update docs tessellate","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"features-0-0-0-9007","dir":"Changelog","previous_headings":"","what":"Features","title":"dbSpatial 0.0.0.9007 (2024-07-03)","text":"Add new tessellate function (WIP) Update st_extent return named character vector Change default sql gen VIEW creation instead table","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"docs-0-0-0-9006","dir":"Changelog","previous_headings":"","what":"Docs","title":"dbSpatial 0.0.0.9006 (2024-03-28)","text":"Update function descriptions.","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"features-0-0-0-9005","dir":"Changelog","previous_headings":"","what":"Features","title":"dbSpatial 0.0.0.9005 (2024-03-27)","text":"Add spatial_relationship functions. Add new internal functions spatial_relationship functions. Use lowercase func names.","code":""},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"chore-0-0-0-9005","dir":"Changelog","previous_headings":"","what":"Chore","title":"dbSpatial 0.0.0.9005 (2024-03-27)","text":"Update roxygen pkgdown reference section.","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"chore-0-0-0-9004","dir":"Changelog","previous_headings":"","what":"Chore","title":"dbSpatial 0.0.0.9004 (2024-03-18)","text":"Update README DESCRIPTION.","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"features-0-0-0-9003","dir":"Changelog","previous_headings":"","what":"Features","title":"dbSpatial 0.0.0.9003 (2024-03-18)","text":"Update constructor function. Update ST_ functions use new constructor.","code":""},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"chore-0-0-0-9003","dir":"Changelog","previous_headings":"","what":"Chore","title":"dbSpatial 0.0.0.9003 (2024-03-18)","text":"Update vignettes class diagram new constructor. Add working examples ST functions.","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"chore-0-0-0-9002","dir":"Changelog","previous_headings":"","what":"Chore","title":"dbSpatial 0.0.0.9002 (2024-01-02)","text":"Update class diagram. Add tictoc imports.","code":""},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"uncategorized-0-0-0-9002","dir":"Changelog","previous_headings":"","what":"Uncategorized","title":"dbSpatial 0.0.0.9002 (2024-01-02)","text":"Merge branch ‘main’ https://github.com/Ed2uiz/dbSpatial.","code":""},{"path":[]},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"bug-fixes-0-0-0-9001","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"dbSpatial 0.0.0.9001 (2024-01-02)","text":"Add missing ’ constructor. Duckdb spatial extension load error GHA workflow.","code":""},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"features-0-0-0-9001","dir":"Changelog","previous_headings":"","what":"Features","title":"dbSpatial 0.0.0.9001 (2024-01-02)","text":"Add terra imports. Add dbplyr imports. Add dplyr imports. Add duckdb imports. Add duckdbfs imports.","code":""},{"path":"https://drieslab.github.io/dbSpatial/news/index.html","id":"chore-0-0-0-9001","dir":"Changelog","previous_headings":"","what":"Chore","title":"dbSpatial 0.0.0.9001 (2024-01-02)","text":"Update docs. Update pkg info. Move index.html /docs. Add license","code":""}]
